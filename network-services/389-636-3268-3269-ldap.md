# 389,636,3268,3269 - LDAP

### Users

{% tabs %}
{% tab title="Linux" %}
```shellscript
# Delete -D and -W to attempt anonymous bind
ldapsearch -H -x ldap://<DC> -D "<DOMAIN>\<USER>" -W -b "DC=<DC>,DC=<DC>" "(&(objectCategory=person)(objectClass=user))"
```
{% endtab %}

{% tab title="Windows" %}
```powershell
Get-ADObject -LDAPFilter '(&(objectCategory=person)(objectClass=user))'
```
{% endtab %}
{% endtabs %}

{% embed url="https://ldapwiki.com/wiki/Wiki.jsp?page=Active+Directory+User+Related+Searches" %}

### Groups

{% tabs %}
{% tab title="Linux" %}
```shellscript
# Delete -D and -W to attempt anonymous bind
ldapsearch -H -x ldap://<DC> -D "<DOMAIN>\<USER>" -W -b "DC=<DC>,DC=<DC>" "(objectClass=group)"
```
{% endtab %}

{% tab title="Windows" %}
```powershell
Get-ADObject -LDAPFilter '(objectClass=group)'
```
{% endtab %}
{% endtabs %}

{% embed url="https://ldapwiki.com/wiki/Wiki.jsp?page=Active+Directory+Group+Related+Searches" %}

### Computers

{% tabs %}
{% tab title="Linux" %}
```shellscript
# Delete -D and -W to attempt anonymous bind
ldapsearch -H -x ldap://<DC> -D "<DOMAIN>\<USER>" -W -b "DC=<DC>,DC=<DC>" "(objectCategory=computer)"
```
{% endtab %}

{% tab title="Windows" %}
```powershell
Get-ADObject -LDAPFilter '(objectCategory=computer)'
```
{% endtab %}
{% endtabs %}

{% embed url="https://ldapwiki.com/wiki/Wiki.jsp?page=Active+Directory+Computer+Related+LDAP+Query" %}

### LDAP Search Filters

#### LDAP Filter Syntax and Operators

LDAP filters must have one or more criteria. If more than one criteria exist, they can be\
concatenated together using logical AND or OR operators. These operators are always\
placed in the front of the criteria (operands)

Some example AND and OR operations are as follows:\
AND Operation:

* One criteria: `(& (..C1..) (..C2..))`
* More than two criteria: `(& (..C1..) (..C2..) (..C3..))`<br>

OR Operation:

* One criteria: `(| (..C1..) (..C2..))`
* More than two criteria: `(| (..C1..) (..C2..) (..C3..))`<br>

We can also have nested operations, for example `(|(& (..C1..) (..C2..))(& (..C3..)`\
`(..C4..)))` translates to "(C1 AND C2) OR (C3 AND C4)".

#### Search Criteria

When writing an LDAP search filter, we need to specify a rule requirement for the LDAP\
attribute in question (i.e. " (displayName=william) "). The following rules can be used to\
specify our search criteria

| Criteria          | Rule               | Example                                 |
| ----------------- | ------------------ | --------------------------------------- |
| Equal To          | (attribute=123)    | (&(objectclass=user)(displayName=Smith) |
| Not Equal To      | (!(attribute=123)) | (!objectClass=group)                    |
| Present           | (attribute=\*)     | (department=\*)                         |
| Not present       | (!(attribute=\*))  | (!homeDirectory=\*)                     |
| Greater than      | (attribute>=123)   | (maxStorage=100000)                     |
| Less than         | (attribute<=123)   | (maxStorage<=100000)                    |
| Approximate match | (attribute\~=123)  | (sAMAccountName\~=Jason)                |
| Wildcards         | (attribute=\*A)    | (givenName=\*Sam)                       |

{% embed url="https://learn.microsoft.com/en-us/windows/win32/adschema/attributes-all" %}

#### Object Identifiers (OIDs)

We can also use matching rule Object Identifiers (OIDs) with LDAP filters as listed in this\
Search Filter Syntax document from Microsoft

{% embed url="https://learn.microsoft.com/en-us/windows/win32/adsi/search-filter-syntax" %}

| Matching rule OID       | String identifier (from Ntldap.h)   | Description                                                                                                                                                                                   |
| ----------------------- | ----------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 1.2.840.113556.1.4.803  | **LDAP\_MATCHING\_RULE\_BIT\_AND**  | A match is found only if all bits from the attribute match the value. This rule is equivalent to a bitwise **AND** operator.                                                                  |
| 1.2.840.113556.1.4.804  | **LDAP\_MATCHING\_RULE\_BIT\_OR**   | A match is found if any bits from the attribute match the value. This rule is equivalent to a bitwise **OR** operator.                                                                        |
| 1.2.840.113556.1.4.1941 | **LDAP\_MATCHING\_RULE\_IN\_CHAIN** | This rule is limited to filters that apply to the DN. This is a special "extended" match operator that walks the chain of ancestry in objects all the way to the root until it finds a match. |

To get the filter value, for the `userAcountControl` attribute, we can use the ressource below. It will indicate us the hex and decimal value for the different flags (ex `ACCOUNTDISABLE`, `DONT_REQ_PREAUTH` ...). Repeat the process for other attributes.

{% embed url="https://learn.microsoft.com/en-us/troubleshoot/windows-server/active-directory/useraccountcontrol-manipulate-account-properties" %}

Explanation :

1Ô∏è‚É£ Where does `userAccountControl` come from?

In **Active Directory**, many account behaviors and security settings are stored in a **single integer attribute**:

üëâ **`userAccountControl` (UAC)**

It is a **bitmask**:

* a single integer value
* each **bit** represents a specific option being enabled or disabled

***

2Ô∏è‚É£ Why `524288`?

Each option corresponds to a **power of two**.

| Flag (hex)       | Value      | Meaning                      |
| ---------------- | ---------- | ---------------------------- |
| `0x00000020`     | 32         | Password not required        |
| `0x00000200`     | 512        | Normal account               |
| `0x00010000`     | 65536      | Password never expires       |
| **`0x00080000`** | **524288** | **TRUSTED\_FOR\_DELEGATION** |

üëâ **524288 = 2¬π‚Åπ**

So:

* if **bit 19** is set to `1`
* the account is **Trusted for delegation**
* which means **unconstrained delegation**

***

3Ô∏è‚É£ Why this strange filter `:1.2.840.113556.1.4.803:`?

This is **the key to LDAP filtering in Active Directory** üóùÔ∏è

Full name :

**LDAP\_MATCHING\_RULE\_BIT\_AND**

OID :

```
1.2.840.113556.1.4.803
```

What it does

It allows LDAP to **test a specific bit** inside a numeric attribute.

üëâ **Syntax**

```ldap
(attribute:OID:=value)
```

üëâ **Meaning**

> ‚ÄúReturn objects where `(attribute & value) == value`‚Äù

***

4Ô∏è‚É£ Full filter breakdown

```ldap
(userAccountControl:1.2.840.113556.1.4.803:=524288)
```

Human-readable interpretation

* `userAccountControl` ‚Üí the UAC attribute
* `:1.2.840.113556.1.4.803:` ‚Üí bitwise AND matching rule
* `524288` ‚Üí TRUSTED\_FOR\_DELEGATION flag

‚û°Ô∏è **‚ÄúAll objects where the TRUSTED\_FOR\_DELEGATION flag is enabled‚Äù**

***

5Ô∏è‚É£ Why not `userAccountControl=524288`?

Because **UAC usually contains multiple flags at the same time**.

Real-world example

```
userAccountControl = 66048
```

üëâ `66048` =

* `65536` ‚Üí Password never expires
* `512` ‚Üí Normal account

So:

```ldap
(userAccountControl=524288)
```

‚ùå matches **only** accounts whose UAC value is _exactly_ 524288

Whereas:

```ldap
(userAccountControl:1.2.840.113556.1.4.803:=524288)
```

‚úîÔ∏è matches **all accounts where this bit is set**, regardless of other flags

{% tabs %}
{% tab title="Linux" %}
```shellscript
# List administratively disabled user accounts
ldapsearch -H -x ldap://<DC> -D "<DOMAIN>\<USER>" -W -b "DC=<DC>,DC=<DC>" "(userAccountControl:1.2.840.113556.1.4.803:=2)"

# Find all groups a user is part of
ldapsearch -H -x ldap://<DC> -D "<DOMAIN>\<USER>" -W -b "DC=<DC>,DC=<DC>" "(member:1.2.840.113556.1.4.1941:=CN=Harry Jones,OU=Network Ops,OU=IT,OU=Employees,DC=INLANEFREIGHT,DC=LOCAL)"
```
{% endtab %}

{% tab title="Windows" %}
```powershell
# List administratively disabled user accounts
Get-ADUser -LDAPFilter '(userAccountControl:1.2.840.113556.1.4.803:=2)' | select name

# Find all groups a user is part of
Get-ADGroup -LDAPFilter '(member:1.2.840.113556.1.4.1941:=CN=Harry Jones,OU=Network Ops,OU=IT,OU=Employees,DC=INLANEFREIGHT,DC=LOCAL)' | select Name
```
{% endtab %}
{% endtabs %}

#### Example LDAP Filters

{% tabs %}
{% tab title="Linux" %}
```shellscript
# List users with non empty Description field
ldapsearch -H -x ldap://<DC> -D "<DOMAIN>\<USER>" -W -b "DC=<DC>,DC=<DC>" "(&(objectCategory=user)(description=*))" sAMAccountName description

# Find trusted users (trusted for delegation or unconstrained delegation)
ldapsearch -H -x ldap://<DC> -D "<DOMAIN>\<USER>" -W -b "DC=<DC>,DC=<DC>" "(&(objectCategory=user)(userAccountControl:1.2.840.113556.1.4.803:=524288))"

# Find trusted computers
ldapsearch -H -x ldap://<DC> -D "<DOMAIN>\<USER>" -W -b "DC=<DC>,DC=<DC>" "(&(objectClass=computer)(userAccountControl:1.2.840.113556.1.4.803:=524288))"

# Find admin accounts with blank passwords 
ldapsearch -H -x ldap://<DC> -D "<DOMAIN>\<USER>" -W -b "DC=<DC>,DC=<DC>" "(&(objectClass=computer)(userAccountControl:1.2.840.113556.1.4.803:=524288))"
```
{% endtab %}

{% tab title="Windows" %}
```powershell
# List users with non empty Description field
Get-ADUser -Properties * -LDAPFilter '(&(objectCategory=user)(description=*))' | select samaccountname,description

# Find trusted users (trusted for delegation or unconstrained delegation)
Get-ADUser -Properties * -LDAPFilter '(userAccountControl:1.2.840.113556.1.4.803:=524288)' | select Name,memberof, servicePrincipalName,TrustedForDelegation | fl

# Find trusted computers
Get-ADComputer -Properties * -LDAPFilter '(userAccountControl:1.2.840.113556.1.4.803:=524288)' | select DistinguishedName,servicePrincipalName,TrustedForDelegation | fl

# Find admin accounts with blank passwords 
Get-AdUser -LDAPFilter '(&(objectCategory=person)(objectClass=user)(userAccountControl:1.2.840.113556.1.4.803:=32)(adminCount=1))' -Properties * | select name,memberof | fl
```
{% endtab %}
{% endtabs %}

{% embed url="https://learn.microsoft.com/en-us/archive/technet-wiki/5392.active-directory-ldap-syntax-filters" %}

#### SearchBase and SearchScope Parameters

**Theory**

We can improve the performance of our enumeration commands and scripts and reduce the\
volume of objects returned by scoping our searches using the " `SearchBase` " parameter.\
This parameter specifies an Active Directory path to search under and allows us to begin\
searching for a user account in a specific OU. The " `SearchBase` " parameter accepts an\
OUs distinguished name (DN) such as "`OU=Employees,DC=INLANEFREIGHT,DC=LOCAL`" .\
" `SearchScope` " allows us to define how deep into the OU hierarchy we would like to search.\
This parameter has three levels:

| Name     | Level | Description                                                                                                                                                                                                                |
| -------- | ----- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Base     | 0     | The object is specified as the `SearchBase` . For example, if we ask for all users in an OU defining a base scope, we get no results. If we specify a user or use `Get-ADObject` we get just that user or object returned. |
| OneLevel | 1     | Searches for objects in the container defined by the `SearchBase` but not in any sub-containers.                                                                                                                           |
| SubTree  | 2     | Searches for objects contained by the `SearchBase` and all child containers, including their children, recursively all the way down the AD hierarchy.                                                                      |

When querying AD using " `SearchScope` " we can specify the name or the number (i.e.,\
SearchScope Onelevel is interpreted the same as " `SearchScope 1` ".)

<figure><img src="https://2006144298-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FBVYdRQWhXrZbqzYeOYpH%2Fuploads%2FNx6ydSJVgTEMbrUvRz0I%2Fimage.png?alt=media&#x26;token=d0bfa4d0-233a-4b81-b75b-9e5c5937d644" alt=""><figcaption></figcaption></figure>

In the above example, with the `SearchBase` set to `OU=Employees,DC=INLANEFREIGHT,DC=LOCAL`, a `SearchScope` set to Base would attempt to query the OU object ( Employees ) itself. A `SearchScope` set to `OneLevel` would search within the Employees OU only. Finally, a `SearchScope` set to `SubTree` would query the Employees OU and all of the OUs underneath it, such as Accounting , Contractors ,\
etc. OUs under those OUs (child containers).

**Examples**

Let's look at some examples to illustrate the difference between `Base` , `OneLevel` , and\
`Subtree` . For these examples, we will focus on the Employees OU. In the screenshot of\
Active Directory Users and Computers below Employees is the `Base` , and specifying it\
with `Get-ADUser` will return nothing. `OneLevel` will return just the user Amelia Matthews ,\
and `SubTree` will return all users in all child containers under the Employees container.

<figure><img src="https://2006144298-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FBVYdRQWhXrZbqzYeOYpH%2Fuploads%2FZq4IDTm6mMHn6k09FtJB%2Fimage.png?alt=media&#x26;token=f2b941b1-0c78-4d37-9c62-093fea734743" alt=""><figcaption></figcaption></figure>

```powershell
# Count all AD users
(Get-ADUser -SearchBase "OU=Employees,DC=INLANEFREIGHT,DC=LOCAL" -Filter *).count
970

# As expected, specifying a SearchScope of Base will return nothing.
Get-ADUser -SearchBase "OU=Employees,DC=INLANEFREIGHT,DC=LOCAL" -SearchScope Base -Filter *

# Specifying OneLevel as the SearchScope, we get one user returned to us, as expected
Get-ADUser -SearchBase "OU=Employees,DC=INLANEFREIGHT,DC=LOCAL" -SearchScope OneLevel -Filter *
Name : Amelia Matthews
ObjectClass : user

# Specifying SubTree as the SearchScope, we get all objets withing all child containers
(Get-ADUser -SearchBase "OU=Employees,DC=INLANEFREIGHT,DC=LOCAL" -SearchScope Subtree -Filter *).count
970
```

### Enumerating Active Directory with Built-in Tools

#### User-Account-Control (UAC) Attributes

User-Account-Control Attributes control the behavior of domain accounts. Many of these UAC\
attributes have security relevance

<figure><img src="https://2006144298-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FBVYdRQWhXrZbqzYeOYpH%2Fuploads%2FwWmqJPfqwDgyLb5m1dWw%2Fimage.png?alt=media&#x26;token=b976ac17-b36c-471e-b1b3-ee001299a90d" alt=""><figcaption></figcaption></figure>

We can list all administrative accounts and the security flags

```powershell
Get-ADUser -Filter {adminCount -gt 0} -Properties admincount,useraccountcontrol | select Name,useraccountcontrol
Name useraccountcontrol
---- ------------------
Administrator 66048
krbtgt 66050
daniel.carter 512
<SNIP>
```

We can convert the security flag values back to their attributes with the following script

```ps1
Function Set-UserAccountControlValueTable
{
	
    $userAccountControlHashTable = New-Object HashTable
    $userAccountControlHashTable.Add("SCRIPT",1)
    $userAccountControlHashTable.Add("ACCOUNTDISABLE",2)
    $userAccountControlHashTable.Add("HOMEDIR_REQUIRED",8) 
    $userAccountControlHashTable.Add("LOCKOUT",16)
    $userAccountControlHashTable.Add("PASSWD_NOTREQD",32)
    $userAccountControlHashTable.Add("ENCRYPTED_TEXT_PWD_ALLOWED",128)
    $userAccountControlHashTable.Add("TEMP_DUPLICATE_ACCOUNT",256)
    $userAccountControlHashTable.Add("NORMAL_ACCOUNT",512)
    $userAccountControlHashTable.Add("INTERDOMAIN_TRUST_ACCOUNT",2048)
    $userAccountControlHashTable.Add("WORKSTATION_TRUST_ACCOUNT",4096)
    $userAccountControlHashTable.Add("SERVER_TRUST_ACCOUNT",8192)
    $userAccountControlHashTable.Add("DONT_EXPIRE_PASSWORD",65536) 
    $userAccountControlHashTable.Add("MNS_LOGON_ACCOUNT",131072)
    $userAccountControlHashTable.Add("SMARTCARD_REQUIRED",262144)
    $userAccountControlHashTable.Add("TRUSTED_FOR_DELEGATION",524288) 
    $userAccountControlHashTable.Add("NOT_DELEGATED",1048576)
    $userAccountControlHashTable.Add("USE_DES_KEY_ONLY",2097152) 
    $userAccountControlHashTable.Add("DONT_REQ_PREAUTH",4194304) 
    $userAccountControlHashTable.Add("PASSWORD_EXPIRED",8388608) 
    $userAccountControlHashTable.Add("TRUSTED_TO_AUTH_FOR_DELEGATION",16777216) 
    $userAccountControlHashTable.Add("PARTIAL_SECRETS_ACCOUNT",67108864)

    $userAccountControlHashTable = $userAccountControlHashTable.GetEnumerator() | Sort-Object -Property Value 
    return $userAccountControlHashTable
}

Function Get-UserAccountControlFlags($userInput)
{    
        Set-UserAccountControlValueTable | foreach {
	    $binaryAnd = $_.value -band $userInput
	    if ($binaryAnd -ne "0") { write $_ }
    }
}

$userInputUserAccountControl = Read-Host "Please provide the userAccountControl value: "
Get-UserAccountControlFlags($userInputUserAccountControl)
```

```powershell
.\Convert-UserAccountControlValues.ps1
Please provide the userAccountControl value: : 4260384
Name Value
---- -----
PASSWD_NOTREQD 32
NORMAL_ACCOUNT 512
DONT_EXPIRE_PASSWORD 65536
DONT_REQ_PREAUTH 4194304
```

Or do it with PowerView

```powershell
Import-Module .\PowerView.ps1

Get-DomainUser * -AdminCount | select samaccountname,useraccountcontrol
-----------
Administrator NORMAL_ACCOUNT, DONT_EXPIRE_PASSWORD
krbtgt ACCOUNTDISABLE, NORMAL_ACCOUNT, DONT_EXPIRE_PASSWORD
daniel.carter NORMAL_ACCOUNT
<SNIP>
```

#### Enumeration Using Built-in Tools

Tools that sysadmins are themselves likely to use, such as the PowerShell AD Module, the\
Sysinternals Suite, and AD DS Tools, are likely to be whitelisted and fly under the radar,\
especially in more mature environments. Several built-in tools can be leveraged for AD\
enumeration

#### **DS Tools**

{% embed url="https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-r2-and-2012/cc732535(v=ws.11)" %}

The tool can't list security flags other than `pwdneverexpires`

```powershell
# Recursively list all member of the Employees OU that have the pwdneverexpires flag set 
# We could also start the search at the root of the domain with DC=inlanefreight,DC=local
dsquery user "OU=Employees,DC=inlanefreight,DC=local" -name * -scope subtree -limit 0 | dsget user -samid -pwdneverexpires | findstr /V no
```

**AD PowerShell Module**

The PowerShell Active Directory module is a group of cmdlets used to manage Active\
Directory. The installation of the AD PowerShell module requires administrative access.

The Get-ADUser cmdlet always needs a filter. That's why we have to specify `-Filter *` to return everything

```powershell
# Recursively list all member of the Employees OU
Get-ADUser -Filter * -SearchBase 'OU=Admin,DC=inlanefreight,dc=local'
```

**Windows Management Instrumentation (WMI)**

```powershell
# List all domain groups
Get-WmiObject -Class win32_group -Filter "Domain='INLANEFREIGHT'" | Select Caption,Name
```

To see what other WMI classes we can user, check below (users, installed softwares ...)

{% embed url="https://www.windows-active-directory.com/wmi-classes-and-categories.html" %}

**AD Service Interfaces (ADSI)**

Uses classic LDAP syntax

```powershell
# List all domain computers
([adsisearcher]"(&(objectClass=Computer))").FindAll() | select Path

# List all domain users
([adsisearcher]"(&(objectCategory=person)(objectClass=user))").FindAll()
```

{% embed url="https://www.secuinfra.com/en/techtalk/adsisearcher-get-the-object-of-interest-search-for-specific-users-and-computers/" %}

### LDAP Anonymous Bind

When an LDAP server allows anonymous base binds, an attacker does not need to know a\
base object to query a considerable amount of information from the domain. Information that we\
obtain from an anonymous LDAP bind can be leveraged to mount a password spraying or\
AS-REPRoasting attack, read information such as passwords stored in account description\
fields.

{% tabs %}
{% tab title="Ldapsearch" %}
```shellscript
# Confirm anonymous bind
ldapsearch -H ldap://<DC> -x -b "dc=<DC>,dc=<DC>"
```
{% endtab %}

{% tab title="Windapsearch" %}
```shellscript
# Confirm anonymous bind
python3 windapsearch.py --dc-ip 10.129.1.207 -u "" --functionality
```
{% endtab %}
{% endtabs %}
